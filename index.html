<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    MIT License

    Copyright (c) 2025 NQR

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
  -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WordLoom - Lightweight Crossword Generator</title>

<style>
:root{
  /* Template color scheme */
  --bg: #0c1020;
  --card: #151c3b;
  --ink: #eef1ff;
  --dim: #b9c6ef;
  --border: #2b3868;
  --accent: #1fc9aa;
  --accent-hover: #18b79a;
  --accent-dark: #17b399;
  --input-bg: #0f1432;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; background:var(--bg); color:var(--ink);
  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  overflow-x:hidden;
}

/* HEADER (from template) */
.app-header {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  padding: 20px 12px 12px;
  text-align: center;
}

.app-logo {
  max-width: 160px;
  height: auto;
  object-fit: contain;
}

.app-title {
  font-size: 1.8rem;
  margin: 2px 0 0 0;
  font-weight: 600;
  letter-spacing: 0.25px;
}

.app-subtitle {
  color: var(--dim);
  font-size: 0.9rem;
  font-style: italic;
  margin: 0 0 2px 0;
}

/* Cards and accents */
.gg-card{
  background:linear-gradient(180deg,#151c3b,#13183a);
  border:1px solid var(--border);
  border-radius:14px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.gg-border{ border-color:var(--border)!important; }
.gg-badge{
  background:#1a2147; color:#a6b6f0; border:1px solid var(--border);
}
.text-dim{ color:var(--dim) }

/* LAYOUT */
.wrap{
  display:grid; gap:18px; padding:18px; max-width:1200px; margin:auto; width:100%;
  grid-template-columns: 1fr; /* mobile-first */
}
@media (min-width: 960px){
  .wrap{ grid-template-columns: 360px 1fr; }
}
.panel,.stage{
  background:linear-gradient(180deg,#151c3b,#13183a);
  border:1px solid var(--border); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.panel{ padding:14px }
.stage{ padding:14px; display:grid; grid-template-rows:auto 1fr; min-height:0; }

/* text */
h1{ font-size:18px; margin:0 0 8px }
.hint{ color:var(--dim); font-size:12px; margin:6px 0 12px }
.footer{ color:#9fb4ff; opacity:.7; font-size:12px; margin-top:10px }

/* inputs */
textarea{
  width:100%; height:180px; resize:vertical; background:#0f1432; color:var(--ink);
  border:1px dashed var(--border); border-radius:12px; padding:10px;
  font:13px/1.4 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
}
.row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0 }
label{ display:flex; align-items:center; gap:8px }
input[type="checkbox"]{ transform:scale(1.1) }
input[type="number"]{
  width:96px; background:#0f1432; color:var(--ink); border:1px solid var(--border);
  border-radius:10px; padding:8px 10px
}
button{
  appearance:none; border:1px solid var(--accent-dark); border-radius:10px; padding:10px 14px;
  color:#0a0e12; background:var(--accent); font-weight:700; cursor:pointer;
  transition: all 0.15s ease;
  box-shadow: 0 2px 4px rgba(31, 201, 170, 0.2);
}
button:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(31, 201, 170, 0.3);
}
button:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(31, 201, 170, 0.2);
}
button.secondary{ background:#1a2147; color:var(--ink); border-color: var(--border) }

/* toolbar */
.toolbar{ display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom:10px }
.stats{ font-size:12px; color:var(--dim); white-space:nowrap; overflow:hidden; text-overflow:ellipsis }

/* PREVIEW: square & never obscured */
.canvas-wrap{
  position:relative; width:100%;
  min-height: clamp(300px, 62vh, 900px);
  aspect-ratio: 1 / 1;
  background:#ffffff; border-radius:12px; overflow:hidden;
  border:1px solid #1f2a57;
}
canvas{ width:100%; height:100%; display:block; background:#fff; }

/* chips */
.tag{ display:inline-block; background:#1a2147; border:1px solid var(--border); color:#cfe5ff;
  padding:2px 8px; border-radius:999px; font-size:11px; margin-right:6px }

/* FOOTER / LICENSE (from template) */
.license-footer {
  margin-top: 30px;
  margin-bottom: 20px;
  padding: 10px 8px;
  font-size: 0.68rem;
  color: var(--dim);
  opacity: 0.7;
  cursor: pointer;
  transition: opacity 0.15s ease;
  text-align: center;
}

.license-footer:hover {
  opacity: 1;
}

.license-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 999;
}

.license-modal {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--card);
  border: 2px solid var(--border);
  border-radius: 12px;
  padding: 20px;
  max-width: 520px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 20px 60px rgba(0,0,0,.6);
  z-index: 1000;
}

.license-modal.show,
.license-overlay.show {
  display: block;
}

.license-modal-header {
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  padding-right: 32px;
  gap: 12px;
}

.license-modal-title {
  margin: 0;
  font-size: 1rem;
  text-align: center;
  width: 100%;
}

.license-modal-close {
  position: absolute;
  top: 0;
  right: 0;
  cursor: pointer;
  font-size: 1.5rem;
  color: var(--dim);
  line-height: 1;
}

.small-muted {
  color: var(--dim);
  font-size: 0.7rem;
}

</style>
</head>
<body>

<!-- HEADER (from template) -->
<header class="app-header">
  <img src="assets/images/logo.png" alt="App Logo" class="app-logo">
  <h1 class="app-title">WordLoom</h1>
  <p class="app-subtitle">Lightweight Crossword Generator by NQR</p>
</header>

<main class="container-lg">
  <div class="wrap">
    <aside class="panel gg-card">
      <h1>WordLoom</h1>
      <div class="hint">
        Paste words (one per line or comma-separated). WordLoom uses multi-start stochastic greedy and local hill-climbing
        to compact the grid and target a square aspect ratio.
      </div>

      <textarea id="wordsInput" spellcheck="false" placeholder="Example:
INFORMATION
THEORY
ALGORITHM
PUZZLE
GRID
LETTER
TOKEN
SQUARE
CROSS
WORD"></textarea>

      <div class="row">
        <button id="generateBtn">Generate</button>
        <button class="secondary" id="saveBtn" title="Download the current preview as PNG">Save PNG</button>
      </div>

      <div class="row">
        <label><input type="checkbox" id="showSolution" checked /> Show solution letters</label>
      </div>

      <div class="row">
        <label>Restarts <input id="restarts" type="number" min="1" max="9999" value="200" /></label>
        <label>Seed <input id="seed" type="number" step="1" value="0" title="0 = random" /></label>
      </div>

      <div class="hint">
        Tips:
        <div class="tag">Longer words help crossings</div>
        <div class="tag">Use 6+ words</div>
        <div class="tag">Try more restarts</div>
      </div>

      <div class="footer">
        Made for rapid puzzle prototyping. No data leaves your browser.
      </div>
    </aside>

    <section class="stage gg-card">
      <div class="toolbar">
        <div class="stats" id="stats">Ready.</div>
        <div class="stats" id="sizeStats"></div>
      </div>
      <div class="canvas-wrap">
        <canvas id="board" width="1200" height="1200" aria-label="Crossword Preview"></canvas>
      </div>
    </section>
  </div>
</main>

<!-- FOOTER / LICENSE (from template) -->
<footer class="license-footer" id="licenseLink">
  MIT License • Developed by NQR • Click to view
</footer>

<div class="license-overlay" id="licenseOverlay"></div>
<div class="license-modal" id="licenseModal" role="dialog" aria-modal="true" aria-labelledby="licenseTitle">
  <div class="license-modal-header">
    <h3 class="license-modal-title" id="licenseTitle">MIT License</h3>
    <span class="license-modal-close" id="licenseClose" aria-label="Close license dialog">&times;</span>
  </div>
  <pre class="small-muted" style="text-align:center; white-space:pre-wrap; margin-top:14px;">
MIT License

Copyright (c) 2025 NQR

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
  </pre>
</div>

<script>

// License modal behavior (from template)
const licenseLink = document.getElementById('licenseLink');
const licenseOverlay = document.getElementById('licenseOverlay');
const licenseModal = document.getElementById('licenseModal');
const licenseClose = document.getElementById('licenseClose');

function openLicense() {
  licenseOverlay.classList.add('show');
  licenseModal.classList.add('show');
}

function closeLicense() {
  licenseOverlay.classList.remove('show');
  licenseModal.classList.remove('show');
}

licenseLink.addEventListener('click', openLicense);
licenseOverlay.addEventListener('click', closeLicense);
licenseClose.addEventListener('click', closeLicense);

// WordLoom functionality (preserved from original)
const board = document.getElementById('board');
const ctx = board.getContext('2d');
const statsEl = document.getElementById('stats');
const sizeStatsEl = document.getElementById('sizeStats');
const inputEl = document.getElementById('wordsInput');
const generateBtn = document.getElementById('generateBtn');
const saveBtn = document.getElementById('saveBtn');
const showSolutionEl = document.getElementById('showSolution');
const restartsEl = document.getElementById('restarts');
const seedEl = document.getElementById('seed');

let currentLayout = null;
let currentShowSolution = true;

/* RNG utils */
let randSeed = {value:0};
function rand(seedObj){
  if (!seedObj.value) { seedObj.value = Math.floor(Math.random() * 2147483648); }
  let t = seedObj.value += 0x6D2B79F5;
  t = Math.imul(t ^ (t >>> 15), 1 | t);
  t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
  return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
}
function shuffle(arr, rngFn = Math.random){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(rngFn() * (i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}

/* Helpers */
function parseWords(raw){
  const words = raw
    .toUpperCase()
    .replace(/[^A-Z0-9,\n \t-]/g,'')
    .split(/[\s,]+/)
    .map(w=>w.trim().replace(/[^A-Z0-9-]/g,''))
    .filter(w=>w.length>=2);
  const seen = new Set(); const out=[];
  for(const w of words.sort((a,b)=>b.length-a.length)){
    if(!seen.has(w)){seen.add(w); out.push(w);}
  }
  return out;
}

function key(x,y){return x+','+y;}
function neighbors4(x,y){return [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];}

/* Placement core */
function placeWord(grid, word, placements, rng){
  if (placements.length===0){
    return {word, x:0, y:0, dir:'H'};
  }
  const candidates=[];
  const letterIndex = new Map();
  for (const k in grid){
    const ch = grid[k].ch;
    if(!letterIndex.has(ch)) letterIndex.set(ch, []);
    const [gx,gy]=k.split(',').map(Number);
    letterIndex.get(ch).push([gx,gy]);
  }
  for (let wi=0; wi<word.length; wi++){
    const ch = word[wi];
    const hits = letterIndex.get(ch) || [];
    for (const [gx,gy] of hits){
      for (const dir of ['H','V']){
        const x = dir==='H' ? gx-wi : gx;
        const y = dir==='V' ? gy-wi : gy;
        const pre = dir==='H' ? key(x-1,y) : key(x,y-1);
        const post = dir==='H' ? key(x+word.length,y) : key(x,y+word.length);
        if (grid[pre] || grid[post]) continue;
        let ok=true;
        for(let i=0;i<word.length;i++){
          const cx = dir==='H' ? x+i : x;
          const cy = dir==='V' ? y+i : y;
          const k = key(cx,cy);
          const cell = grid[k];
          if (cell){
            if (cell.ch!==word[i]){ok=false; break;}
          } else {
            if (dir==='H'){
              if (grid[key(cx,cy-1)]||grid[key(cx,cy+1)]){ok=false;break;}
            } else {
              if (grid[key(cx-1,cy)]||grid[key(cx+1,cy)]){ok=false;break;}
            }
          }
        }
        if (ok) candidates.push({word,x,y,dir});
      }
    }
  }
  if (candidates.length===0) return null;
  return candidates[Math.floor(rng()*candidates.length)];
}
function buildGrid(placements){
  const g={};
  for (const {word,x,y,dir} of placements){
    for (let i=0;i<word.length;i++){
      const cx = dir==='H' ? x+i : x;
      const cy = dir==='V' ? y+i : y;
      g[key(cx,cy)] = {ch:word[i]};
    }
  }
  return g;
}
function bboxFromPlacements(placements){
  let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
  for (const {word,x,y,dir} of placements){
    if (dir==='H'){
      minx=Math.min(minx,x); maxx=Math.max(maxx,x+word.length-1);
      miny=Math.min(miny,y); maxy=Math.max(maxy,y);
    } else {
      minx=Math.min(minx,x); maxx=Math.max(maxx,x);
      miny=Math.min(miny,y); maxy=Math.max(maxy,y+word.length-1);
    }
  }
  return {minx,miny,maxx,maxy,w:maxx-minx+1,h:maxy-miny+1};
}
function layoutScore(placements){
  if (!placements.length) return {score:1e9,meta:{bb:{w:0,h:0},letters:0,crossings:0,fillBBox:0}};
  const bb = bboxFromPlacements(placements);
  const grid = buildGrid(placements);
  let letters=0,crossings=0,usedCells=0;
  for (const k in grid){
    letters++; usedCells++;
  }
  const visited = new Set();
  for (const {word,x,y,dir} of placements){
    for (let i=0;i<word.length;i++){
      const cx = dir==='H' ? x+i : x; const cy = dir==='V' ? y+i : y;
      const k = key(cx,cy);
      if (visited.has(k)) crossings++; else visited.add(k);
    }
  }
  const area = bb.w*bb.h;
  const fillBBox = usedCells/area;
  const ratio = Math.max(bb.w/bb.h, bb.h/bb.w);
  const aspectPenalty = Math.pow(ratio-1, 2);
  const holes = countHoles(grid);
  const score =
    area*0.7 +
    aspectPenalty*400 +
    (1-fillBBox)*800 +
    holes*30 -
    crossings*8;
  return {score, meta:{bb,usedCells,letters,crossings,fillBBox,holes}};
}
function countHoles(grid){
  const coords = Object.keys(grid).map(s=>s.split(',').map(Number));
  if (!coords.length) return 0;
  let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
  for (const [x,y] of coords){minx=Math.min(minx,x);miny=Math.min(miny,y);maxx=Math.max(maxx,x);maxy=Math.max(maxy,y);}
  let holes=0;
  for (let y=miny;y<=maxy;y++){
    for (let x=minx;x<=maxx;x++){
      const k = key(x,y);
      if (grid[k]) continue;
      const nb = neighbors4(x,y).filter(([nx,ny])=>grid[key(nx,ny)]);
      if (nb.length===4) holes++;
    }
  }
  return holes;
}

/* Local improvement */
function validatePlacements(placements){
  const grid={};
  for (const {word,x,y,dir} of placements){
    const pre = dir==='H' ? key(x-1,y) : key(x,y-1);
    const post = dir==='H' ? key(x+word.length,y) : key(x,y+word.length);
    if (grid[pre] || grid[post]) return false;
    for (let i=0;i<word.length;i++){
      const cx = dir==='H' ? x+i : x; const cy = dir==='V' ? y+i : y;
      const k = key(cx,cy); const cell = grid[k];
      if (cell && cell.ch!==word[i]) return false;
      if (!cell){
        if (dir==='H'){
          if (grid[key(cx,cy-1)] || grid[key(cx,cy+1)]) return false;
        } else {
          if (grid[key(cx-1,cy)] || grid[key(cx+1,cy)]) return false;
        }
      }
      grid[k] = {ch:word[i]};
    }
  }
  return true;
}
function localImprove(placements){
  let best = placements.map(p=>({...p}));
  let {score:bestScore} = layoutScore(best);
  const rngFn = () => rand(randSeed);
  for (let iter=0; iter<200; iter++){
    const idx = Math.floor(Math.random()*best.length);
    const variant = best.map(p=>({...p}));
    const target = variant[idx];
    const original = {...target};
    const tries = [
      {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},
      {flip:true}
    ];
    shuffle(tries, rngFn);
    let improved=false;
    for (const t of tries){
      Object.assign(target, original);
      if (t.flip) target.dir = target.dir==='H'?'V':'H';
      else {target.x+=t.dx; target.y+=t.dy;}
      if (!validatePlacements(variant)) continue;
      const {score} = layoutScore(variant);
      if (score < bestScore){
        bestScore = score;
        best = variant.map(p=>({...p}));
        improved=true;
        break;
      }
    }
  }
  return best;
}

/* Driver */
function generateCrossword(words, restarts=200, seed=0){
  randSeed.value = seed|0;
  const rng = ()=>rand(randSeed);
  const baseOrder = [...words].sort((a,b)=>b.length-a.length);

  let best = null, bestScore = Infinity, bestMeta=null;

  outer: for (let r=0;r<restarts;r++){
    const order = [...baseOrder];
    for (let i=0;i<order.length;i++){
      const j = Math.max(0, Math.min(order.length-1, i + Math.floor((rng()-0.5)*3)));
      [order[i],order[j]]=[order[j],order[i]];
    }
    const placements=[];
    let grid={};
    for (let w of order){
      const p = placeWord(grid, w, placements, rng);
      if (!p){ continue; }
      placements.push(p);
      grid = buildGrid(placements);
    }
    if (placements.length===0) continue;

    let improved = localImprove(placements);
    const {score, meta} = layoutScore(improved);
    if (score < bestScore){ bestScore = score; best = improved; bestMeta = meta; }
    if (bestMeta && bestMeta.fillBBox>0.70 &&
        (Math.max(bestMeta.bb.w/bestMeta.bb.h, bestMeta.bb.h/bestMeta.bb.w) < 1.15)){
      break outer;
    }
  }
  return {placements:best||[], meta:bestMeta||{bb:{w:0,h:0},letters:0,crossings:0,fillBBox:0,usedCells:0}};
}

/* Render */
function normalizePlacements(placements){
  const bb = bboxFromPlacements(placements);
  const dx = -bb.minx, dy=-bb.miny;
  return placements.map(p=>({...p,x:p.x+dx,y:p.y+dy}));
}
function render(layout, showSolution=true){
  ctx.clearRect(0,0,board.width,board.height);
  if (!layout || layout.placements.length===0){
    ctx.fillStyle='#ffffff';
    ctx.fillRect(0,0,board.width,board.height);
    ctx.fillStyle='#888';
    ctx.font='16px system-ui, sans-serif';
    ctx.textAlign='center';
    ctx.fillText('Your crossword will appear here.', board.width/2, board.height/2);
    return;
  }
  const placements = normalizePlacements(layout.placements);
  const grid = buildGrid(placements);
  const bb = bboxFromPlacements(placements);

  const pad = 40;
  const cols = bb.w, rows = bb.h;
  const cell = Math.floor(Math.min((board.width-2*pad)/cols, (board.height-2*pad)/rows));
  const ox = Math.floor((board.width - cell*cols)/2);
  const oy = Math.floor((board.height - cell*rows)/2);

  ctx.fillStyle='#ffffff';
  ctx.fillRect(0,0,board.width,board.height);

  ctx.lineWidth=1;
  ctx.strokeStyle='#111';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.font = Math.floor(cell*0.55) + 'px ui-monospace, Menlo, Consolas, monospace';

  for (let y=0;y<rows;y++){
    for (let x=0;x<cols;x++){
      const k = key(x,y);
      if (grid[k]){
        ctx.fillStyle='#ffffff';
        ctx.fillRect(ox+x*cell, oy+y*cell, cell, cell);
        ctx.strokeStyle='#000000';
        ctx.strokeRect(ox+x*cell+0.5, oy+y*cell+0.5, cell-1, cell-1);
        if (showSolution){
          ctx.fillStyle='#111';
          ctx.fillText(grid[k].ch, ox+x*cell + cell/2, oy+y*cell + cell/2 + 0.5);
        }
      } else {
        ctx.fillStyle='#000000';
        ctx.fillRect(ox+x*cell, oy+y*cell, cell, cell);
      }
    }
  }
  ctx.strokeStyle='#2b2b2b';
  ctx.lineWidth=2;
  ctx.strokeRect(ox-1, oy-1, cell*cols+2, cell*rows+2);
}
function updateStats(layout){
  if (!layout || layout.placements.length===0){
    statsEl.textContent = 'No layout.';
    sizeStatsEl.textContent = '';
    return;
  }
  const m = layout.meta;
  const ratio = m.bb.w && m.bb.h ? (m.bb.w/m.bb.h) : 1;
  statsEl.textContent =
    'Letters: ' + m.letters +
    ' | Crossings: ' + m.crossings +
    ' | Fill-in-BBox: ' + (m.fillBBox*100).toFixed(1) + '%';
  sizeStatsEl.textContent =
    'Grid: ' + m.bb.w + 'x' + m.bb.h +
    ' (aspect ' + (Math.max(ratio,1/ratio)).toFixed(3) + ' from square)';
}

/* UI */
generateBtn.addEventListener('click', ()=>{
  const list = parseWords(inputEl.value);
  if (list.length<2){
    alert('Please provide at least two valid words (letters/numbers/hyphen).');
    return;
  }
  const restarts = Math.max(1, Math.min(5000, parseInt(restartsEl.value||200,10)));
  const seed = parseInt(seedEl.value||0,10);
  const t0 = performance.now();
  const layout = generateCrossword(list, restarts, seed);
  const t1 = performance.now();

  currentLayout = layout;
  updateStats(layout);
  currentShowSolution = showSolutionEl.checked;
  render(layout, currentShowSolution);
  const ms = Math.max(1, Math.round(t1-t0));
  statsEl.textContent += ' | Built in ' + ms + ' ms' +
    ' | Words placed: ' + layout.placements.length + '/' + list.length;
});

showSolutionEl.addEventListener('change', (e)=>{
  currentShowSolution = !!e.target.checked;
  render(currentLayout, currentShowSolution);
});

saveBtn.addEventListener('click', ()=>{
  if (!currentLayout || currentLayout.placements.length===0){
    alert('Nothing to save yet - generate a crossword first.');
    return;
  }
  const url = board.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'wordloom-crossword.png';
  document.body.appendChild(a);
  a.click();
  a.remove();
});

/* Initial render & demo content */
render(null, true);
inputEl.value = 'INFORMATION\nTHEORY\nALGORITHM\nPUZZLE\nGRID\nLETTER\nTOKEN\nSQUARE\nCROSS\nWORD\nSEARCH\nSTATE\nHEURISTIC\nCOMPACT\nRANDOM\nRESTARTS\nSEED';
</script>
</body>
</html>
